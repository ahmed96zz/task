// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package task

import (
	"context"
)

const createProfile = `-- name: CreateProfile :one
INSERT INTO "profile" (
  "first_name", "last_name"
) VALUES (
  $1, $2
) RETURNING "id"
`

type CreateProfileParams struct {
	FirstName string
	LastName  string
}

func (q *Queries) CreateProfile(ctx context.Context, arg CreateProfileParams) (int32, error) {
	row := q.db.QueryRow(ctx, createProfile, arg.FirstName, arg.LastName)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO "users" (
"id", "phone_number"
) VALUES (
  $1 , $2 
)
`

type CreateUserParams struct {
	ID          int32
	PhoneNumber string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser, arg.ID, arg.PhoneNumber)
	return err
}

const isOTPExpired = `-- name: IsOTPExpired :one
SELECT EXISTS(SELECT "otp_expiration_time" FROM "users" WHERE "otp" = $1 AND  phone_number = $2  AND "otp_expiration_time" > current_timestamp LIMIT 1) AS valid
`

type IsOTPExpiredParams struct {
	Otp         string
	PhoneNumber string
}

func (q *Queries) IsOTPExpired(ctx context.Context, arg IsOTPExpiredParams) (bool, error) {
	row := q.db.QueryRow(ctx, isOTPExpired, arg.Otp, arg.PhoneNumber)
	var valid bool
	err := row.Scan(&valid)
	return valid, err
}

const isValidUserOTP = `-- name: IsValidUserOTP :one
SELECT EXISTS(SELECT "otp_expiration_time" FROM "users" WHERE "otp" = $1 AND  phone_number = $2  LIMIT 1) AS valid
`

type IsValidUserOTPParams struct {
	Otp         string
	PhoneNumber string
}

func (q *Queries) IsValidUserOTP(ctx context.Context, arg IsValidUserOTPParams) (bool, error) {
	row := q.db.QueryRow(ctx, isValidUserOTP, arg.Otp, arg.PhoneNumber)
	var valid bool
	err := row.Scan(&valid)
	return valid, err
}

const phoneExisted = `-- name: PhoneExisted :one
SELECT EXISTS(SELECT 1 FROM "profile" WHERE "last_name" = $1 LIMIT 1)
`

func (q *Queries) PhoneExisted(ctx context.Context, lastName string) (bool, error) {
	row := q.db.QueryRow(ctx, phoneExisted, lastName)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const selectProfiles = `-- name: SelectProfiles :many
SELECT id, first_name, last_name, address FROM "profile"
`

func (q *Queries) SelectProfiles(ctx context.Context) ([]Profile, error) {
	rows, err := q.db.Query(ctx, selectProfiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Profile
	for rows.Next() {
		var i Profile
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Address,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setOTP = `-- name: SetOTP :exec
UPDATE "users"
  set "otp" = $2,
  "otp_expiration_time" = current_timestamp + (interval '1 minute')
WHERE "phone_number" = $1
`

type SetOTPParams struct {
	PhoneNumber string
	Otp         string
}

func (q *Queries) SetOTP(ctx context.Context, arg SetOTPParams) error {
	_, err := q.db.Exec(ctx, setOTP, arg.PhoneNumber, arg.Otp)
	return err
}
